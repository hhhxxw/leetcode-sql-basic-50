它考察的核心在于如何处理同一张表内不同行之间的比较（特别是基于日期的时间序列数据）。

---

### 题目概述

**题目描述：**  
给定一个 `Weather` 表，包含以下列：

- `id` (int): 主键。
- `recordDate` (date): 日期。
- `temperature` (int): 当天的温度。

**目标：**  
编写一个 SQL 查询，来查找与之前（昨天）相比温度更高的所有日期的 `id`。

**关键难点：**

- 表中的记录可能不是按照日期排序的。
- 日期可能是不连续的（例如，有1号的数据，然后直接跳到了3号，缺了2号）。因此，不能简单地比较 `id` 或行号，必须严格比较**日期差值**。

---

### 解题思路

由于需要比较同一张表中“今天”和“昨天”的数据，这涉及到**行与行之间的比较**。在 SQL 中，处理这类问题的标准方法是使用 **自连接 （join/inner join）**。

可以想象将 `Weather` 表复制一份，分别命名为 `w1` 和 `w2`：

- 表 `w1`：代表“今天”的数据。
- 表 `w2`：代表“昨天”的数据。

**连接条件 (Join Condition)：**  
需要找到这样的一对数据，满足以下两个条件：

1. **时间关系**：`w1` 的日期必须比 `w2` 的日期恰好大 1 天。
2. **温度关系**：`w1` 的温度必须大于 `w2` 的温度。

---

### SQL 代码

这里主要涉及日期的计算。MySQL 提供了 `DATEDIFF` 函数，非常适合处理此类问题。

`DATEDIFF(date1, date2)` 返回 `date1 - date2` 的天数差。

```sql
SELECT w1.id
FROM Weather w1
JOIN Weather w2
ON DATEDIFF(w1.recordDate, w2.recordDate) = 1
WHERE w1.temperature > w2.temperature;
```